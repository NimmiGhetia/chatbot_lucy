'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _async = require('async');

var _async2 = _interopRequireDefault(_async);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _wordpos = require('wordpos');

var _wordpos2 = _interopRequireDefault(_wordpos);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const wordpos = new _wordpos2.default();

// Unhandled promises should throw top-level errors, not just silently fail
// This is a shim for wordnet lookup.
// http://wordnet.princeton.edu/wordnet/man/wninput.5WN.html

process.on('unhandledRejection', err => {
  throw err;
});

const define = function define(word, cb) {
  wordpos.lookup(word).then(results => {
    if (!_lodash2.default.isEmpty(results)) {
      cb(null, results[0].def);
    } else {
      cb(`No results for wordnet definition of '${ word }'`);
    }
  });
};

// Does a word lookup
// @word can be a word or a word/pos to filter out unwanted types
const lookup = function lookup(word, pointerSymbol = '~', cb) {
  let pos = null;

  const match = word.match(/~(\w)$/);
  if (match) {
    pos = match[1];
    word = word.replace(match[0], '');
  }

  const synets = [];

  wordpos.lookup(word).then(results => {
    results.forEach(result => {
      result.ptrs.forEach(part => {
        if (pos !== null && part.pos === pos && part.pointerSymbol === pointerSymbol) {
          synets.push(part);
        } else if (pos === null && part.pointerSymbol === pointerSymbol) {
          synets.push(part);
        }
      });
    });

    const itor = (word, next) => {
      wordpos.seek(word.synsetOffset, word.pos).then(sub => {
        next(null, sub.lemma);
      });
    };

    _async2.default.map(synets, itor, (err, items) => {
      items = _lodash2.default.uniq(items);
      items = items.map(x => x.replace(/_/g, ' '));
      cb(err, items);
    });
  });
};

// Used to explore a word or concept
// Spits out lots of info on the word
const explore = function explore(word, cb) {
  let ptrs = [];

  wordpos.lookup(word).then(results => {
    for (let i = 0; i < results.length; i++) {
      ptrs.push(results[i].ptrs);
    }

    ptrs = _lodash2.default.uniq(_lodash2.default.flatten(ptrs));
    ptrs = _lodash2.default.map(ptrs, item => ({ pos: item.pos, sym: item.pointerSymbol }));

    ptrs = _lodash2.default.chain(ptrs).groupBy('pos').map((value, key) => ({
      pos: key,
      ptr: _lodash2.default.uniq(_lodash2.default.map(value, 'sym'))
    })).value();

    const itor = (item, next) => {
      const itor2 = (ptr, next2) => {
        lookup(`${ word }~${ item.pos }`, ptr, (err, res) => {
          if (err) {
            console.error(err);
          }
          console.log(word, item.pos, ':', ptr, res.join(', '));
          next2();
        });
      };
      _async2.default.map(item.ptr, itor2, next);
    };
    _async2.default.each(ptrs, itor, () => cb());
  });
};

exports.default = {
  define,
  explore,
  lookup
};